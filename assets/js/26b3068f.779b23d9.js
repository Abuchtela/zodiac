"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[823],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),u=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return o.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=a,h=p["".concat(s,".").concat(m)]||p[m]||c[m]||r;return n?o.createElement(h,i(i({ref:t},d),{},{components:n})):o.createElement(h,i({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var u=2;u<r;u++)i[u]=n[u];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6261:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return d},default:function(){return p}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],l={sidebar_position:2},s="Build Your Module",u={unversionedId:"tutorial-build-a-module/create_module",id:"tutorial-build-a-module/create_module",isDocsHomePage:!1,title:"Build Your Module",description:"What is a module?",source:"@site/docs/tutorial-build-a-module/02_create_module.md",sourceDirName:"tutorial-build-a-module",slug:"/tutorial-build-a-module/create_module",permalink:"/zodiac/docs/tutorial-build-a-module/create_module",editUrl:"https://github.com/gnosis/zodiac/edit/master/website/docs/tutorial-build-a-module/02_create_module.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Setup",permalink:"/zodiac/docs/tutorial-build-a-module/setup"},next:{title:"Deploy Your Module",permalink:"/zodiac/docs/tutorial-build-a-module/deploy_module"}},d=[{value:"What is a module?",id:"what-is-a-module",children:[]},{value:"Import Module.sol",id:"import-modulesol",children:[]},{value:"Factory Friendly",id:"factory-friendly",children:[]}],c={toc:d};function p(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"build-your-module"},"Build Your Module"),(0,r.kt)("h2",{id:"what-is-a-module"},"What is a module?"),(0,r.kt)("p",null,"By default, Gnosis Safes operate as multisig wallets, requiring confirmation from ",(0,r.kt)("em",{parentName:"p"},"n")," of ",(0,r.kt)("em",{parentName:"p"},"m"),' signers in order to execute transactions. However, in addition to (or instead of) using the multisig logic, you can enable "modules" on your Gnosis Safe. Modules are simply addresses that are allowed to bypass the normal multisig logic by calling some special functions, ',(0,r.kt)("inlineCode",{parentName:"p"},"execTransactionFromModule()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"execTransactionFromModuleReturnData()"),"."),(0,r.kt)("p",null,"Earlier, you deployed and set up a Mock Safe and a Button that can only be pushed by the Mock Safe."),(0,r.kt)("p",null,"Now we'll create a Module that can trigger the Mock Safe to push the Button."),(0,r.kt)("h2",{id:"import-modulesol"},"Import Module.sol"),(0,r.kt)("p",null,"First and foremost, Zodiac is a philosophy for building composable DAO tooling. To make easier on aspiring module developers, we've built a library of tools that you can import into your own contracts to help ensure your modules are Zodiac compatible and to reduce the amount of time and effort for you to implement your module."),(0,r.kt)("p",null,"Simply import ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gnosis/zodiac/blob/master/contracts/core/Module.sol"},"Module.sol")," from the Zodiac library and add whatever logic your module needs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'pragma solidity ^0.8.6;\n\nimport "@gnosis.pm/zodiac/contracts/core/Module.sol";\n\ncontract MyModule is Module {\n  /// insert your code here\n}\n')),(0,r.kt)("p",null,"In our case, we want to add a function to tell our Safe to push the button."),(0,r.kt)("p",null,"Define and ",(0,r.kt)("inlineCode",{parentName:"p"},"address button")," variable and add a ",(0,r.kt)("inlineCode",{parentName:"p"},"pushButton")," function to your contract which calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"exec()")," function from ",(0,r.kt)("inlineCode",{parentName:"p"},"Module.sol"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"exec()")," will call the ",(0,r.kt)("inlineCode",{parentName:"p"},"execTransactionFromModule()")," function on the connected Safe.\nIt has four parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"to:")," the address that the safe will call. The Button contract in our case."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"value:")," the amount of ETH in wei that should be sent with the transaction. This is zero in our case."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"data:")," the ABI encoded transaction data that the data for the safe's transaction. In our case this is the function selector for the ",(0,r.kt)("inlineCode",{parentName:"li"},"pushButton()")," function."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"operation:")," defines whether the transaction should be a call or a delegate call. In our case, we'll just do a call.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'address button;\n\nfunction pushButton() external {\n    exec(\n        button,\n        0,\n        abi.encodePacked(bytes4(keccak256("pushButton()"))),\n        Enum.Operation.Call\n    );\n}\n')),(0,r.kt)("p",null,"That's essentially it!\nThe bulk of your work in creating a module is defining the conditions under which ",(0,r.kt)("inlineCode",{parentName:"p"},"exec()")," can be called."),(0,r.kt)("h2",{id:"factory-friendly"},"Factory Friendly"),(0,r.kt)("p",null,"Wait... I'm still seeing compiler errors."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Module.sol")," provides another convenience feature to enable any module to be compatible with our ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gnosis/zodiac/blob/master/contracts/factory/ModuleProxyFactory.sol"},"ModuleProxyFactory")," and the Zodiac Safe App. This makes it easier to streamline deployment and setup of modules so, for example, we can do things like batch deployment of a safe, its modules, and the calls to enable the modules into one Ethereum transaction. \ud83e\udd2f"),(0,r.kt)("p",null,"Before our contract will compile, you'll need to add a constructor and a setup function.\nNotice that our constructor simply ABI encodes the parameters that were passed in and then calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"setUp()")," function. This gives users the option to deploy the module directly, or to deploy it using the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gnosis/zodiac/blob/master/contracts/factory/ModuleProxyFactory.sol"},"ModuleProxyFactory"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"constructor(address _owner, address _button) {\n    bytes memory initializeParams = abi.encode(_owner, _button);\n    setUp(initializeParams);\n}\n\n/// @dev Initialize function, will be triggered when a new proxy is deployed\n/// @param initializeParams Parameters of initialization encoded\nfunction setUp(bytes memory initializeParams) public override {\n    __Ownable_init();\n    (address _owner, address _button) = abi.decode(initializeParams, (address, address));\n\n    button = _button;\n    setAvatar(_owner);\n    setTarget(_owner);\n    transferOwnership(_owner);\n}\n")),(0,r.kt)("p",null,"Our ",(0,r.kt)("inlineCode",{parentName:"p"},"setUp()")," function will set the ",(0,r.kt)("inlineCode",{parentName:"p"},"button")," address, then ",(0,r.kt)("inlineCode",{parentName:"p"},"avatar"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"target"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"owner")," will all be set to the same address.\nIn most cases, these three addresses will be set to the same, but there are subtle distinctions between the three and sometimes they may need to be different."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Avatar:")," is the Safe. The Address that will ultimately execute the transaction that is passed by the module."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Target:")," is the address that this module will call ",(0,r.kt)("inlineCode",{parentName:"li"},"execTransactionFromModule()")," on. In most cases this will be the Safe, but in some cases it could be a special kind of module called a ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/gnosis/zodiac/blob/master/contracts/core/Modifier.sol"},"modifier"),", that sits between a module and an avatar and... well... modifies the transactions passed to it in some way."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Owner:")," is the address that has permissions to call ",(0,r.kt)("inlineCode",{parentName:"li"},"OnlyOwner()")," functions on the module.")),(0,r.kt)("p",null,"In case your ",(0,r.kt)("inlineCode",{parentName:"p"},"MyModule.sol")," is still not compiled, ",(0,r.kt)("a",{parentName:"p",href:"https://gist.github.com/auryn-macmillan/841906d0bc6c2624e83598cdfac17de8"},"here's one we baked earlier"),"."))}p.isMDXComponent=!0}}]);